// This is your Prisma schema file
// For more information: https://pris.ly/d/prisma-schema

generator client {
  provider = "prisma-client-js"
}

datasource db {
  provider = "postgresql"
  url      = env("DATABASE_URL")
}

// ============================================================================
// ENUMS
// ============================================================================

enum UserRole {
  ADMIN
  SUBSCRIBER
}

enum GeoLevel {
  STATE
  DISTRICT
  CONSTITUENCY
  WARD
  BOOTH
}

enum ElectionType {
  ASSEMBLY
  PARLIAMENT
  MUNICIPAL
}

enum ModerationStatus {
  PENDING
  APPROVED
  REJECTED
}

enum SentimentLabel {
  POSITIVE
  NEUTRAL
  NEGATIVE
}

enum DataSourceType {
  NEWS
  ANALYST
}

enum JobStatus {
  PENDING
  RUNNING
  COMPLETED
  FAILED
}

// ============================================================================
// GEOGRAPHY (Future-proof, but minimal for v0)
// ============================================================================

/// Hierarchical geographic unit supporting state -> district -> constituency -> ward -> booth
model GeoUnit {
  id        Int      @id @default(autoincrement())
  name      String
  code      String?  // Optional: official government code
  level     GeoLevel

  // Self-referential hierarchy
  parentId  Int?
  parent    GeoUnit?  @relation("GeoHierarchy", fields: [parentId], references: [id], onDelete: Restrict)
  children  GeoUnit[] @relation("GeoHierarchy")

  // Relations to other models
  electionResultsRaw   ElectionResultRaw[]
  geoElectionSummaries GeoElectionSummary[]
  geoAccess            GeoAccess[]
  sentimentSignals     SentimentSignal[]
  dailyStats           DailyGeoStats[]

  createdAt DateTime @default(now())

  // Indexes for performance
  @@index([parentId]) // Hierarchy traversal
  @@index([level])    // Filtering by geography level
  @@index([code])     // Lookup by official code
}

// ============================================================================
// POLITICAL ENTITIES
// ============================================================================

model Party {
  id        Int      @id @default(autoincrement())
  name      String
  symbol    String?
  colorHex  String?

  // Relations
  candidates         Candidate[]
  electionResultsRaw ElectionResultRaw[]
  voteSummaries      PartyVoteSummary[]

  @@index([name]) // Search/filter by party name
}

model Candidate {
  id        Int     @id @default(autoincrement())
  fullName  String
  gender    String?
  age       Int?
  category  String? // SC/ST/OBC/General

  partyId   Int
  party     Party   @relation(fields: [partyId], references: [id], onDelete: Restrict)

  // Relations
  electionResultsRaw ElectionResultRaw[]

  @@index([partyId])
}

// ============================================================================
// ELECTIONS
// ============================================================================

model Election {
  id        Int          @id @default(autoincrement())
  year      Int
  type      ElectionType
  stateId   Int?         // Optional: for future flexibility

  // Relations
  resultsRaw       ElectionResultRaw[]
  electionSummaries GeoElectionSummary[]

  createdAt DateTime @default(now())

  @@index([year, type]) // Common query pattern
}

// ============================================================================
// RAW ELECTION RESULTS (ETL Input - Source of Truth)
// ============================================================================

/// Raw election results data imported via ETL
/// This is the source of truth - dashboards should NOT query this directly
model ElectionResultRaw {
  id            Int @id @default(autoincrement())

  electionId    Int
  geoUnitId     Int
  candidateId   Int
  partyId       Int

  votesGeneral  Int
  votesPostal   Int
  votesTotal    Int

  // Relations
  election      Election  @relation(fields: [electionId], references: [id], onDelete: Cascade)
  geoUnit       GeoUnit   @relation(fields: [geoUnitId], references: [id], onDelete: Restrict)
  candidate     Candidate @relation(fields: [candidateId], references: [id], onDelete: Restrict)
  party         Party     @relation(fields: [partyId], references: [id], onDelete: Restrict)

  @@index([electionId, geoUnitId]) // Common query pattern for ETL and aggregation
  @@index([candidateId])
  @@index([partyId])
}

// ============================================================================
// AGGREGATED ELECTION ANALYTICS (Dashboard-Ready)
// ============================================================================

/// Pre-computed election summary at geography level
/// Dashboards and APIs query THIS, not ElectionResultRaw
model GeoElectionSummary {
  id               Int   @id @default(autoincrement())
  electionId       Int
  geoUnitId        Int

  totalElectors    Int
  totalVotesCast   Int
  turnoutPercent   Float

  winningParty     String
  winningCandidate String
  winningMargin    Int
  winningMarginPct Float

  notaVotes        Int
  notaPercent      Float

  // Relations
  election         Election           @relation(fields: [electionId], references: [id], onDelete: Cascade)
  geoUnit          GeoUnit            @relation(fields: [geoUnitId], references: [id], onDelete: Restrict)
  partyResults     PartyVoteSummary[]

  @@unique([electionId, geoUnitId]) // Prevent duplicate summaries
  @@index([geoUnitId])
}

/// Party-wise vote breakdown for a geography in an election
model PartyVoteSummary {
  id                   Int   @id @default(autoincrement())
  geoElectionSummaryId Int
  partyId              Int

  voteCount            Int
  voteSharePercent     Float

  // Relations
  party                Party              @relation(fields: [partyId], references: [id], onDelete: Restrict)
  summary              GeoElectionSummary @relation(fields: [geoElectionSummaryId], references: [id], onDelete: Cascade)

  @@index([geoElectionSummaryId])
  @@index([partyId])
}

// ============================================================================
// USERS & SUBSCRIPTIONS
// ============================================================================

model User {
  id        Int      @id @default(autoincrement())
  fullName  String
  phone     String   @unique
  role      UserRole

  // Relations
  subscription Subscription?
  alerts       Alert[]

  createdAt DateTime @default(now())
  updatedAt DateTime @updatedAt

  @@index([phone]) // Login lookup
  @@index([role])  // Admin queries
}

model Subscription {
  id        Int       @id @default(autoincrement())
  userId    Int       @unique
  startsAt  DateTime
  endsAt    DateTime?

  // Relations
  user      User       @relation(fields: [userId], references: [id], onDelete: Cascade)
  access    GeoAccess[]

  @@index([startsAt, endsAt]) // Active subscription queries
}

/// Geography-based access control
model GeoAccess {
  id             Int
  subscriptionId Int
  geoUnitId      Int

  // Relations
  subscription   Subscription @relation(fields: [subscriptionId], references: [id], onDelete: Cascade)
  geoUnit        GeoUnit      @relation(fields: [geoUnitId], references: [id], onDelete: Restrict)

  @@id([subscriptionId, geoUnitId])
  @@index([geoUnitId])
}

// ============================================================================
// NEWS & SENTIMENT (Controlled & Safe)
// ============================================================================

/// Curated news articles requiring moderation
model NewsArticle {
  id          Int      @id @default(autoincrement())
  title       String
  summary     String   @db.Text
  sourceName  String
  sourceUrl   String
  publishedAt DateTime

  status      ModerationStatus @default(PENDING)

  // Relations
  sentimentSignals SentimentSignal[]

  createdAt   DateTime @default(now())
  updatedAt   DateTime @updatedAt

  @@index([status])      // Moderation workflow
  @@index([publishedAt]) // Recent news queries
}

/// Sentiment derived from curated sources (news, analyst reports)
model SentimentSignal {
  id             Int      @id @default(autoincrement())
  geoUnitId      Int
  sourceType     DataSourceType
  sourceRefId    Int      // References NewsArticle.id (not enforced for flexibility)

  sentiment      SentimentLabel
  sentimentScore Float    // -1.0 to 1.0
  confidence     Float    // 0.0 to 1.0

  createdAt      DateTime @default(now())

  // Relations
  geoUnit        GeoUnit      @relation(fields: [geoUnitId], references: [id], onDelete: Restrict)
  newsArticle    NewsArticle? @relation(fields: [sourceRefId], references: [id], onDelete: SetNull)

  @@index([geoUnitId, createdAt]) // Time-series analytics
  @@index([sourceType])
}

// ============================================================================
// DAILY AGGREGATED ANALYTICS (Performance Critical)
// ============================================================================

/// Pre-computed daily analytics per geography
/// Used by dashboards for trend analysis
model DailyGeoStats {
  id           Int      @id @default(autoincrement())
  geoUnitId    Int
  date         DateTime @db.Date

  avgSentiment Float    // Average sentiment score for the day
  pulseScore   Float    // Composite score (custom algorithm)
  dominantIssue String? // Most discussed topic/issue

  // Relations
  geoUnit      GeoUnit @relation(fields: [geoUnitId], references: [id], onDelete: Restrict)

  @@unique([geoUnitId, date]) // One record per geography per day
  @@index([date])             // Trend queries across geographies
}

// ============================================================================
// ALERTS
// ============================================================================

/// User-specific alerts generated by background jobs
model Alert {
  id         Int      @id @default(autoincrement())
  userId     Int
  geoUnitId  Int
  message    String   @db.Text
  isRead     Boolean  @default(false)

  createdAt  DateTime @default(now())

  // Relations
  user       User     @relation(fields: [userId], references: [id], onDelete: Cascade)
  // Note: No relation to GeoUnit to allow alerts for deleted geographies

  @@index([userId, isRead]) // User's unread alerts
  @@index([createdAt])      // Recent alerts
}

// ============================================================================
// ETL & JOB TRACKING
// ============================================================================

/// Background job execution tracking
model Job {
  id        Int       @id @default(autoincrement())
  jobType   String    // e.g., "election_etl", "sentiment_aggregation"
  status    JobStatus @default(PENDING)

  startedAt DateTime
  endedAt   DateTime?
  errorLog  String?   @db.Text

  @@index([jobType, status]) // Job monitoring queries
  @@index([startedAt])       // Recent jobs
}
