// This is your Prisma schema file
// For more information: https://pris.ly/d/prisma-schema

generator client {
  provider = "prisma-client-js"
}

datasource db {
  provider = "postgresql"
  url      = env("DATABASE_URL")
}

// ============================================================================
// ENUMS
// ============================================================================

enum UserRole {
  ADMIN
  SUBSCRIBER
  CANDIDATE
  ANALYST
  PARTY_MEMBER
}

enum GeoLevel {
  STATE
  DISTRICT
  CONSTITUENCY
  WARD
  BOOTH
}

enum ElectionType {
  ASSEMBLY
  PARLIAMENT
  MUNICIPAL
}

enum ModerationStatus {
  PENDING
  APPROVED
  REJECTED
}

enum SentimentLabel {
  POSITIVE
  NEUTRAL
  NEGATIVE
}

enum DataSourceType {
  NEWS
  ANALYST
}

enum JobStatus {
  PENDING
  RUNNING
  COMPLETED
  FAILED
}

enum NewsIngestType {
  API
  SCRAPER
  MANUAL
  PARTNER
}

enum ManualInputType {
  FILE
  LINK
  TEXT
}

enum EntityType {
  GEO_UNIT
  CANDIDATE
  PARTY
}

enum AlertType {
  SENTIMENT_SPIKE
  CONTROVERSY
  NEWS_MENTION
  DAILY_PULSE
}

// ============================================================================
// GEOGRAPHY (Future-proof, but minimal for v0)
// ============================================================================

/// Hierarchical geographic unit supporting state -> district -> constituency -> ward -> booth
model GeoUnit {
  id        Int      @id @default(autoincrement())
  name      String
  code      String?  // Optional: official government code
  level     GeoLevel

  // Self-referential hierarchy
  parentId  Int?
  parent    GeoUnit?  @relation("GeoHierarchy", fields: [parentId], references: [id], onDelete: Restrict)
  children  GeoUnit[] @relation("GeoHierarchy")

  // Relations to other models
  electionResultsRaw   ElectionResultRaw[]

  geoElectionSummaries GeoElectionSummary[]
  marginSummaries      ConstituencyMarginSummary[]
  competitiveness      SeatCompetitivenessSummary[]
  geoAccess            GeoAccess[]
  sentimentSignals     SentimentSignal[]
  dailyStats           DailyGeoStats[]
  candidateProfiles    CandidateProfile[]

  createdAt DateTime @default(now())

  // Indexes for performance
  @@index([parentId]) // Hierarchy traversal
  @@index([level])    // Filtering by geography level
  @@index([code])     // Lookup by official code
}

// ============================================================================
// POLITICAL ENTITIES
// ============================================================================

model Party {
  id        Int      @id @default(autoincrement())
  name      String
  symbol    String?
  colorHex  String?

  // Relations
  candidates         Candidate[]
  electionResultsRaw ElectionResultRaw[]
  voteSummaries      PartyVoteSummary[]
  seatSummaries      PartySeatSummary[]
  wonElections       ElectionSeatSummary[]
  wonMargins         ConstituencyMarginSummary[] @relation("WinningMargins")
  runnerUpMargins    ConstituencyMarginSummary[] @relation("RunnerUpMargins")
  winningSeatsCompetitiveness SeatCompetitivenessSummary[]
  candidateProfiles  CandidateProfile[]

  @@index([name]) // Search/filter by party name
}

model Candidate {
  id        Int     @id @default(autoincrement())
  fullName  String
  gender    String?
  age       Int?
  category  String? // SC/ST/OBC/General

  partyId   Int
  party     Party   @relation(fields: [partyId], references: [id], onDelete: Restrict)

  // Relations
  electionResultsRaw ElectionResultRaw[]
  profile            CandidateProfile?

  @@index([partyId])
}

model CandidateProfile {
  candidateId        Int @id
  userId             Int? @unique  // NULL for opponents
  primaryGeoUnitId   Int            // Constituency
  partyId            Int
  isSelf             Boolean @default(false)
  importanceWeight   Float   @default(1.0) // CM > MLA > Ward

  // Subscription & Monitoring Control ✨ NEW
  isSubscribed       Boolean @default(false)
  subscriptionId     Int?
  monitoringStartedAt DateTime?
  monitoringEndedAt   DateTime?

  candidate Candidate @relation(fields: [candidateId], references: [id], onDelete: Cascade)
  user      User?     @relation(fields: [userId], references: [id])
  geoUnit   GeoUnit   @relation(fields: [primaryGeoUnitId], references: [id])
  party     Party     @relation(fields: [partyId], references: [id])

  createdAt DateTime @default(now())
  updatedAt DateTime @updatedAt

  @@index([isSubscribed])
  @@index([monitoringStartedAt])
}

/// Entity Monitoring - Flexible activation gating
/// Tracks which entities are actively monitored and why
model EntityMonitoring {
  id         Int      @id @default(autoincrement())
  entityType EntityType
  entityId   Int
  isActive   Boolean  @default(true)
  priority   Int      @default(5)     // 1-10 scale (10=Highest, 1=Lowest)
  reason     String   // SUBSCRIBED | OPPONENT | PARTY_CONTEXT | GEO_CONTEXT
  
  // Links back to the primary subscriber (the candidate who triggered this)
  triggeredByCandidateId Int?
  
  createdAt  DateTime @default(now())
  updatedAt  DateTime @updatedAt

  @@unique([entityType, entityId])
  @@index([isActive])
  @@index([reason])
  @@index([triggeredByCandidateId])
}

// ============================================================================
// ELECTIONS
// ============================================================================

model Election {
  id        Int          @id @default(autoincrement())
  year      Int
  type      ElectionType
  stateId   Int?         // Optional: for future flexibility

  // Relations
  resultsRaw       ElectionResultRaw[]
  electionSummaries GeoElectionSummary[]

  seatSummaries    PartySeatSummary[]
  electionSeatSummary ElectionSeatSummary?
  marginSummaries  ConstituencyMarginSummary[]
  competitiveness  SeatCompetitivenessSummary[]

  createdAt DateTime @default(now())

  @@index([year, type]) // Common query pattern
}

// ============================================================================
// RAW ELECTION RESULTS (ETL Input - Source of Truth)
// ============================================================================

/// Raw election results data imported via ETL
/// This is the source of truth - dashboards should NOT query this directly
model ElectionResultRaw {
  id            Int @id @default(autoincrement())

  electionId    Int
  geoUnitId     Int
  candidateId   Int
  partyId       Int

  votesGeneral  Int
  votesPostal   Int
  votesTotal    Int

  // Relations
  election      Election  @relation(fields: [electionId], references: [id], onDelete: Cascade)
  geoUnit       GeoUnit   @relation(fields: [geoUnitId], references: [id], onDelete: Restrict)
  candidate     Candidate @relation(fields: [candidateId], references: [id], onDelete: Restrict)
  party         Party     @relation(fields: [partyId], references: [id], onDelete: Restrict)

  @@index([electionId, geoUnitId]) // Common query pattern for ETL and aggregation
  @@index([candidateId])
  @@index([partyId])
}

// ============================================================================
// AGGREGATED ELECTION ANALYTICS (Dashboard-Ready)
// ============================================================================

/// Pre-computed election summary at geography level
/// Dashboards and APIs query THIS, not ElectionResultRaw
model GeoElectionSummary {
  id               Int   @id @default(autoincrement())
  electionId       Int
  geoUnitId        Int

  totalElectors    Int
  totalVotesCast   Int
  turnoutPercent   Float

  winningParty     String
  winningCandidate String
  winningMargin    Int
  winningMarginPct Float

  notaVotes        Int
  notaPercent      Float

  // Relations
  election         Election           @relation(fields: [electionId], references: [id], onDelete: Cascade)
  geoUnit          GeoUnit            @relation(fields: [geoUnitId], references: [id], onDelete: Restrict)
  partyResults     PartyVoteSummary[]

  @@unique([electionId, geoUnitId]) // Prevent duplicate summaries
  @@index([geoUnitId])
}

/// Party-wise vote breakdown for a geography in an election
model PartyVoteSummary {
  id                   Int   @id @default(autoincrement())
  geoElectionSummaryId Int
  partyId              Int

  voteCount            Int
  voteSharePercent     Float

  // Relations
  party                Party              @relation(fields: [partyId], references: [id], onDelete: Restrict)
  summary              GeoElectionSummary @relation(fields: [geoElectionSummaryId], references: [id], onDelete: Cascade)

  @@index([geoElectionSummaryId])
  @@index([partyId])
}

/// Aggregated seat share per party per election
model PartySeatSummary {
  id         Int @id @default(autoincrement())
  electionId Int
  partyId    Int
  seatsWon   Int

  // Relations
  election Election @relation(fields: [electionId], references: [id], onDelete: Cascade)
  party    Party    @relation(fields: [partyId], references: [id], onDelete: Restrict)

  @@unique([electionId, partyId])
}

/// Computed election outcome (seats, majority, winner)
model ElectionSeatSummary {
  id             Int      @id @default(autoincrement())
  electionId     Int      @unique
  totalSeats     Int
  majorityMark   Int
  winningPartyId Int?
  isHungAssembly Boolean
  createdAt      DateTime @default(now())

  // Relations
  election     Election  @relation(fields: [electionId], references: [id], onDelete: Cascade)
  winningParty Party?    @relation(fields: [winningPartyId], references: [id], onDelete: SetNull)

  @@index([winningPartyId])
}

/// Margin analysis per constituency
model ConstituencyMarginSummary {
  id              Int      @id @default(autoincrement())
  geoUnitId       Int
  electionId      Int

  winningPartyId  Int
  runnerUpPartyId Int

  winningVotes    Int
  runnerUpVotes   Int
  marginVotes     Int
  marginPercent   Float

  createdAt       DateTime @default(now())

  // Relations
  geoUnit         GeoUnit @relation(fields: [geoUnitId], references: [id], onDelete: Restrict)
  election        Election @relation(fields: [electionId], references: [id], onDelete: Cascade)
  winningParty    Party    @relation("WinningMargins", fields: [winningPartyId], references: [id], onDelete: Restrict)
  runnerUpParty   Party    @relation("RunnerUpMargins", fields: [runnerUpPartyId], references: [id], onDelete: Restrict)

  @@unique([geoUnitId, electionId])
  @@index([geoUnitId])
  @@index([electionId])
  @@index([marginVotes])
}

/// Analysis of seat safety based on margin
model SeatCompetitivenessSummary {
  id             Int      @id @default(autoincrement())
  geoUnitId      Int
  electionId     Int
  winningPartyId Int
  marginPercent  Float
  classification String   // SAFE, MARGINAL, SWING

  createdAt      DateTime @default(now())

  // Relations
  geoUnit        GeoUnit  @relation(fields: [geoUnitId], references: [id], onDelete: Restrict)
  election       Election @relation(fields: [electionId], references: [id], onDelete: Cascade)
  winningParty   Party    @relation(fields: [winningPartyId], references: [id], onDelete: Restrict)

  @@unique([geoUnitId, electionId])
  @@index([classification])
  @@index([electionId])
}

// ============================================================================
// USERS & SUBSCRIPTIONS
// ============================================================================

model User {
  id        Int      @id @default(autoincrement())
  fullName  String
  email     String?  @unique // Optional: can login via email OR phone
  phone     String   @unique
  passwordHash String // bcrypt hashed password
  role      UserRole
  isActive  Boolean  @default(true) // Admin can deactivate users
  
  // Trial user support
  isTrial   Boolean  @default(false)

  // Relations
  subscription Subscription?
  alerts       Alert[]
  sessions     Session[]
  impersonatedSessions ImpersonationSession[] @relation("ImpersonatedUser")
  adminImpersonations  ImpersonationSession[] @relation("AdminImpersonator")
  passwordResetOtps    PasswordResetOtp[]
  candidateProfile     CandidateProfile?

  createdAt DateTime @default(now())
  updatedAt DateTime @updatedAt

  @@index([email])
  @@index([phone]) // Login lookup
  @@index([role])  // Admin queries
  @@index([isActive])
}

model Session {
  id            String   @id @default(uuid()) // Session token
  userId        Int
  
  // Device tracking for single-device enforcement
  deviceInfo    String?
  ipAddress     String?
  
  // Session lifecycle
  createdAt     DateTime @default(now())
  expiresAt     DateTime // Calculated from SESSION_DURATION_DAYS env
  lastActivityAt DateTime @default(now())
  revoked       Boolean  @default(false)
  
  // Relations
  user          User     @relation(fields: [userId], references: [id], onDelete: Cascade)
  
  @@index([userId])
  @@index([expiresAt])
  @@index([lastActivityAt])
}

model ImpersonationSession {
  id               String    @id @default(uuid())
  adminId          Int
  targetUserId     Int
  
  // Impersonation context for audit trail
  reason           String?   @db.Text
  ipAddress        String?
  deviceInfo       String?
  
  // Lifecycle
  createdAt        DateTime  @default(now())
  expiresAt        DateTime  // Auto-expire after IMPERSONATION_DURATION_HOURS
  endedAt          DateTime? // Explicit end or admin logout
  endReason        String?   // "ADMIN_LOGOUT" | "EXPLICIT_STOP" | "EXPIRED"
  
  // Relations
  admin            User      @relation("AdminImpersonator", fields: [adminId], references: [id], onDelete: Cascade)
  targetUser       User      @relation("ImpersonatedUser", fields: [targetUserId], references: [id], onDelete: Cascade)
  
  @@index([adminId])
  @@index([targetUserId])
  @@index([createdAt])
  @@index([endedAt])
}

/// Password Reset OTP for forgot password flow
model PasswordResetOtp {
  id        String   @id @default(uuid())
  userId    Int
  otp       String   // 6-digit OTP
  attempts  Int      @default(0) // Rate limiting (max 3)
  createdAt DateTime @default(now())
  expiresAt DateTime // 10 minutes from creation
  
  // Relations
  user      User     @relation(fields: [userId], references: [id], onDelete: Cascade)
  
  @@index([userId])
  @@index([expiresAt])
}

model Subscription {
  id        Int       @id @default(autoincrement())
  userId    Int       @unique
  
  // Trial vs Paid
  isTrial   Boolean   @default(false)
  
  // Lifecycle
  startsAt  DateTime
  endsAt    DateTime? // NULL = lifetime, otherwise expiry date
  
  // Manual creation tracking
  createdByAdminId Int?

  // Relations
  user      User       @relation(fields: [userId], references: [id], onDelete: Cascade)
  access    GeoAccess[]

  @@index([startsAt, endsAt]) // Active subscription queries
  @@index([isTrial])
}

///Geography-based access control
model GeoAccess {
  id             Int
  subscriptionId Int
  geoUnitId      Int

  // Relations
  subscription   Subscription @relation(fields: [subscriptionId], references: [id], onDelete: Cascade)
  geoUnit        GeoUnit      @relation(fields: [geoUnitId], references: [id], onDelete: Restrict)

  @@id([subscriptionId, geoUnitId])
  @@index([geoUnitId])
}

// ============================================================================
// NEWS & SENTIMENT (Controlled & Safe)
// ============================================================================

/// Curated news articles requiring moderation
model NewsArticle {
  id          Int      @id @default(autoincrement())
  title       String
  summary     String   @db.Text
  sourceName  String
  sourceUrl   String
  publishedAt DateTime

  status      ModerationStatus @default(PENDING)

  // Ingestion Metadata
  ingestType      NewsIngestType   @default(API)
  submittedBy     Int?             // userId for MANUAL ingestion
  manualInputType ManualInputType?
  originalFileUrl String?          // S3 / storage URL

  // Relations
  sentimentSignals SentimentSignal[]
  entityMentions   NewsEntityMention[]

  createdAt   DateTime @default(now())
  updatedAt   DateTime @updatedAt

  @@index([status])      // Moderation workflow
  @@index([publishedAt]) // Recent news queries
  @@index([ingestType])
}

model NewsEntityMention {
  id        Int @id @default(autoincrement())
  articleId Int
  entityType EntityType
  entityId  Int

  // Relations
  article   NewsArticle @relation(fields: [articleId], references: [id], onDelete: Cascade)

  @@index([articleId])
  @@index([entityType, entityId])
}

/// Sentiment derived from curated sources (news, analyst reports)
model SentimentSignal {
  id             Int      @id @default(autoincrement())
  geoUnitId      Int
  sourceType     DataSourceType
  sourceRefId    Int      // References NewsArticle.id (not enforced for flexibility)

  sentiment      SentimentLabel
  sentimentScore Float    // -1.0 to 1.0
  confidence     Float    // 0.0 to 1.0
  modelVersion   String?  // e.g. "kn-en-v1" for model traceability

  // ✨ Relevance Weights (Feature 1) - Performance optimization
  relevanceWeight   Float?       // 0.4-1.0 (calculated and stored for fast queries)
  sourceEntityType  EntityType?  // Which entity type triggered this signal
  sourceEntityId    Int?         // ID of that entity

  createdAt      DateTime @default(now())

  // Relations
  geoUnit        GeoUnit      @relation(fields: [geoUnitId], references: [id], onDelete: Restrict)
  newsArticle    NewsArticle? @relation(fields: [sourceRefId], references: [id], onDelete: SetNull)

  @@index([geoUnitId, createdAt]) // Time-series analytics
  @@index([sourceType])
  @@index([relevanceWeight])
  @@index([sourceEntityType, sourceEntityId])
}

// ============================================================================
// DAILY AGGREGATED ANALYTICS (Performance Critical)
// ============================================================================

/// Pre-computed daily analytics per geography
/// Used by dashboards for trend analysis
model DailyGeoStats {
  id           Int      @id @default(autoincrement())
  geoUnitId    Int
  date         DateTime @db.Date

  avgSentiment Float    // Average sentiment score for the day
  pulseScore   Float    // Composite score (custom algorithm)
  dominantIssue String? // Most discussed topic/issue

  // Relations
  geoUnit      GeoUnit @relation(fields: [geoUnitId], references: [id], onDelete: Restrict)

  @@unique([geoUnitId, date]) // One record per geography per day
  @@index([date])             // Trend queries across geographies
}

// ============================================================================
// ALERTS
// ============================================================================

/// User-specific alerts generated by background jobs
model Alert {
  id         Int      @id @default(autoincrement())
  userId     Int
  geoUnitId  Int
  type       AlertType
  message    String   @db.Text
  isRead     Boolean  @default(false)

  createdAt  DateTime @default(now())

  // Relations
  user       User     @relation(fields: [userId], references: [id], onDelete: Cascade)
  // Note: No relation to GeoUnit to allow alerts for deleted geographies

  @@index([userId, isRead]) // User's unread alerts
  @@index([createdAt])      // Recent alerts
}

// ============================================================================
// ETL & JOB TRACKING
// ============================================================================

/// Background job execution tracking
model Job {
  id        Int       @id @default(autoincrement())
  jobType   String    // e.g., "election_etl", "sentiment_aggregation"
  status    JobStatus @default(PENDING)

  startedAt DateTime
  endedAt   DateTime?
  errorLog  String?   @db.Text

  @@index([jobType, status]) // Job monitoring queries
  @@index([startedAt])       // Recent jobs
}

// ============================================================================
// KEYWORD MANAGEMENT (Industry Standard: Hybrid Approach)
// ============================================================================

/// Keywords for news fetching and filtering
/// Managed by admins + auto-seeded from entities
model NewsKeyword {
  id          Int       @id @default(autoincrement())
  keyword     String
  entityType  EntityType   // GEO_UNIT, CANDIDATE, PARTY
  entityId    Int
  
  isActive    Boolean   @default(true)
  priority    Int       @default(1) // higher = more important
  
  // Future: query syntax/modifiers (e.g., "required", "exclude")
  
  createdAt   DateTime @default(now())
  updatedAt   DateTime @updatedAt

  @@index([entityType, entityId]) // Lookup keywords for specific entity
  @@index([isActive])             // Filter active keywords
  @@unique([entityType, entityId, keyword]) // Prevent duplicates
}
